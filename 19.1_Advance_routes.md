## Advance Routes

1. `loader` function
   - When we want to implement some code before routing to a route, we can use loader function
   - Like calling an endpoint to fetch some data
   - loader function is called before the JSX code in `to` gets executes
   - The response of the loader function will get available to the JSX code to be executed.
   - Loader function gets 2 parameters `request` and `params`

```
    {
    index: true,
    element: <EventPage />,
    loader: async ({request, params}) => {
        const response = await fetch("http://localhost:8080/events");

        if (!response.ok) {
        //...
        } else {
        const resData = await response.json();
        return resData.events;
        }
    },
    }
```

2. Using `loader` data usage using `useLoaderData`
   - Call the `useLoaderData` as a function, it will return the data passed in the `loader` function
   - Even if the data returned from the `loader` function is a promise, it will unwrap it and gives only the value
   - We can directly use the `useLoaderData` in the `EventsList` as well as it is used in the `EventsPage`

```
function EventsPage() {
  const data = useLoaderData();
  return <EventsList events={data} />;
}

```

3. Where to keep the logic of `loader` function
   - we can keep it in the router itself as shown in the previous examples
   - Or better way is to extract the function and keep it in the same JS file that contains the component where we are routing.
   - Like in the above example we are routing to `EventPage`, so we can keep the function in it.

```
import { useLoaderData } from "react-router-dom";

import EventsList from "../components/EventsList";

function EventsPage() {
  const data = useLoaderData();

  return <EventsList events={data} />;
}

export default EventsPage;

export async function loader({request, params}) {
  const response = await fetch("http://localhost:8080/events");

  if (!response.ok) {
    //...
  } else {
    const resData = await response.json();
    return resData.events;
  }
}

```

```
import EventPage, { loader as eventsLoader } from "./pages/Events.js";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    children: [
      {
        path: "events", element: <EventsRootLayout />,
        children: [
          {
            index: true,
            element: <EventPage />,
            loader: eventsLoader,
          },
        ],
      },
    ],
  },
]);
```

4. Reflecting the state on HMI using `useNavigation`
   - When the `loader` code is in progress, the HMI looks hung
   - So we can use `useNavigation` hook to check the current state of the loader
   - Based on the state of the loader, we can show some text to user like (loading is in progress)
   - `useNavigation` must not be used on the component where we are redirection but must be used on some parent component that is already visible on the screen
   - Three possible values are : `idle, loading, submitting`

```
import { Outlet, useNavigation } from "react-router-dom";
import MainNavigation from "../components/MainNavigation";

export default function Root() {
    const navigation = useNavigation();

    return <>
        <MainNavigation />

        <main>
            {navigation.state === 'loading' && <p>Loading...</p>}
            <Outlet />
        </main>
    </>
}

```

5. Error Handling
   - One way is to send an object with error properties and then in the redirected component check if the error properties are present.
   - Better way is to throw an error
   - This thrown error will be caught by the nearest `errorElement` in the routes.
   - First it checks if the route where we defined the loader itself has `errorElement`, then its parent route, till the top most route.
   - If an `errorElement` is defined then that component will get loaded

```
export async function loader() {
  const response = await fetch("http://localhost:8080/eventss");

  if (!response.ok) {
    return {isError: true, message: 'Could not fetch events.'};
  } else {
    return response;
  }
}
```

```
export async function loader() {
  const response = await fetch("http://localhost:8080/eventss");

  if (!response.ok) {
    //return {isError: true, message: 'Could not fetch events.'};
    throw {message: 'Could not fetch events.'};
  } else {
    return response;
  }
}
```

6. Handling error message in a `errorElement`
   - It gets called when we put wrong URL or when we have an error in a child loader
   - So we have to show specific messages in different scenarios
   - First we have to send a `Response` object from the loader function with the error code and message
   - We can get hold of that `Response` object in the `errorElement` component using `useRouteError`.

```
export async function loader() {
  const response = await fetch("http://localhost:8080/eventss");

  if (!response.ok) {
    throw new Response(JSON.stringify({ message: "Could not fetch events." }), {
      status: 500
    });
  } else {
    return response;
  }
}
```

```
import { useRouteError } from "react-router-dom";
import PageContent from "../components/PageContent";

export default function ErrorPage() {

    const error = useRouteError();

    let title = 'An error occured!';
    let message = 'Something went wrong!';

    if(error.status === 500) {
        message = JSON.parse(error.data).message;
    }

    if(error.status === 404) {
        title = 'Not found!';
        message = 'Could not found resource or page!'
    }

    return <PageContent title={title}>
        <p>{message}</p>
    </PageContent>;
}
```

7. Using higher route loader
   - When we want to use a loader from a higher route like from parent route
   - It is helpful when multiple child component needs same kind of loader
   - We need to add `id` in the parent route where we are defining the loader
   - In the child component to fetch the loader data, we need to use `useRouteLoaderData` hook instead of `useLoaderData` hook.
   - In the hook pass the `id` of the route whose loader we want to use

```
  {
    path: ":eventId",
    id: 'event-details',
    loader: eventDetailLoader,
    children: [
      {
        index: true,
        element: <EventDetailPage />,
      },
      { path: "edit", element: <EditEventPage /> },
    ]
  }

```

```
  import {useRouteLoaderData } from 'react-router-dom';
  import EventForm from '../components/EventForm';

  export default function EditEventPage() {
      const data = useRouteLoaderData('event-details');
      const event = data.event;
      return <EventForm event={event}/>
  }
```

8. `actions` to send data
   - Just like we have loaders to load data we have `actions` to send data
   - Actions are called when we try to send any request from the component like submitting a form
   - Actions are defined just like the loader in the route definition
   - The implementation is also defined in the same component on which we are applying the action, in this case `NewEventPage` component
   - If we have a form that we are submitting then we have to change the element from `form` to `Form`
   - Import `Form` from `react-router-dom`
   - define the method type on the form
   - All the fields of the form must have a name property
   - Just like the loader, action also take 2 parameters : request and params.
   - Submitting the form takes the flow to the action.

```
  { path: "new", element: <NewEventPage />, action: newEventAction },
```

```
  <Form method='post'>
        <p>
          <label htmlFor="title">Title</label>
          <input id="title" type="text" name="title" required defaultValue={event ? event.title: ''}/>
        </p>
        ...
  </Form>
```

```
export async function action({ request, params }) {
  const data = await request.formData();

  const eventData = {
    title: data.get("title"),
    description: data.get("description"),
  };

  const response = await fetch("http://localhost:8080/events", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(eventData),
  });

  if (!response.ok) {
    throw new Response(JSON.stringify({ message: "Could not save event!" }), {
      status: 500,
    });
  }

  return redirect('/events');

}
```

9. Other action in the Form
   - If we want to call another action from the Form element not the one mentioned in its component routing definition
   - then we can define it in the `Form` element
   - value of the action is the path of any other component and an action must be specified on that path

```
  <Form method='post' action="/new-event">
        <p>
          <label htmlFor="title">Title</label>
          <input id="title" type="text" name="title" required defaultValue={event ? event.title: ''}/>
        </p>
        ...
  </Form>
```

10. Other way to call the actions
    - One way is to submit the form and use the `Form` from `react-router-dom`
    - In case we dont have a form and still we want to submit something like deleting an item
    - In that case we can use `useSubmit` from `react-router-dom`

```


```

11. `redirect`
    - Creates a special type of response object that is used to redirect to a different routing path.
    - `useSubmit` returns a function that we can use to send a request with body and metadata
    - In case of delete there is no data to send, so null value is used in the below example


```
function EventItem({ event }) {
  const submit = useSubmit();

  function startDeleteHandler() {
    const proceed = window.confirm('Are you sure?');

    if(proceed) {
      submit(null, {method: 'DELETE'});
    }
  }

  ...

} 
```