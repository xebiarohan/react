## Advance Routes

1. `loader` function
   - When we want to implement some code before routing to a route, we can use loader function
   - Like calling an endpoint to fetch some data
   - loader function is called before the JSX code in `to` gets executes
   - The response of the loader function will get available to the JSX code to be executed.
   - Loader function gets 2 parameters `request` and `params`

```
    {
    index: true,
    element: <EventPage />,
    loader: async ({request, params}) => {
        const response = await fetch("http://localhost:8080/events");

        if (!response.ok) {
        //...
        } else {
        const resData = await response.json();
        return resData.events;
        }
    },
    }
```

2. Using `loader` data usage using `useLoaderData`
   - Call the `useLoaderData` as a function, it will return the data passed in the `loader` function
   - Even if the data returned from the `loader` function is a promise, it will unwrap it and gives only the value
   - We can directly use the `useLoaderData` in the `EventsList` as well as it is used in the `EventsPage`

```
function EventsPage() {
  const data = useLoaderData();
  return <EventsList events={data} />;
}

```

3. Where to keep the logic of `loader` function
   - we can keep it in the router itself as shown in the previous examples
   - Or better way is to extract the function and keep it in the same JS file that contains the component where we are routing.
   - Like in the above example we are routing to `EventPage`, so we can keep the function in it.

```
import { useLoaderData } from "react-router-dom";

import EventsList from "../components/EventsList";

function EventsPage() {
  const data = useLoaderData();

  return <EventsList events={data} />;
}

export default EventsPage;

export async function loader({request, params}) {
  const response = await fetch("http://localhost:8080/events");

  if (!response.ok) {
    //...
  } else {
    const resData = await response.json();
    return resData.events;
  }
}

```

```
import EventPage, { loader as eventsLoader } from "./pages/Events.js";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    children: [
      {
        path: "events", element: <EventsRootLayout />,
        children: [
          {
            index: true,
            element: <EventPage />,
            loader: eventsLoader,
          },
        ],
      },
    ],
  },
]);
```

4. Reflecting the state on HMI using `useNavigation`
   - When the `loader` code is in progress, the HMI looks hung
   - So we can use `useNavigation` hook to check the current state of the loader
   - Based on the state of the loader, we can show some text to user like (loading is in progress)
   - `useNavigation` must not be used on the component where we are redirection but must be used on some parent component that is already visible on the screen
   - Three possible values are : `idle, loading, submitting`

```
import { Outlet, useNavigation } from "react-router-dom";
import MainNavigation from "../components/MainNavigation";

export default function Root() {
    const navigation = useNavigation();
    
    return <>
        <MainNavigation />

        <main>
            {navigation.state === 'loading' && <p>Loading...</p>}
            <Outlet />
        </main>
    </>
}

```

5. Error Handling
   - One way is to send an object with error properties and then in the redirected component check if the error properties are present.
   - Better way is to throw an error
   - This thrown error will be caught by the nearest `errorElement` in the routes.
   - First it checks if the route where we defined the loader itself has `errorElement`, then its parent route, till the top most route.
   - If an `errorElement` is defined then that component will get loaded

```
export async function loader() {
  const response = await fetch("http://localhost:8080/eventss");

  if (!response.ok) {
    return {isError: true, message: 'Could not fetch events.'};
  } else {
    return response;
  }
}
```

```
export async function loader() {
  const response = await fetch("http://localhost:8080/eventss");

  if (!response.ok) {
    //return {isError: true, message: 'Could not fetch events.'};
    throw {message: 'Could not fetch events.'};
  } else {
    return response;
  }
}
```

6. Handling error message in a `errorElement`
   - It gets called when we put wrong URL or when we have an error in a child loader
   - So we have to show specific messages in different scenarios
   - First we have to send a `Response` object from the loader function with the error code and message
   - We can get hold of that `Response` object in the `errorElement` component using `useRouteError`.

```
export async function loader() {
  const response = await fetch("http://localhost:8080/eventss");

  if (!response.ok) {
    throw new Response(JSON.stringify({ message: "Could not fetch events." }), {
      status: 500
    });
  } else {
    return response;
  }
}
```

```
import { useRouteError } from "react-router-dom";
import PageContent from "../components/PageContent";

export default function ErrorPage() {

    const error = useRouteError();

    let title = 'An error occured!';
    let message = 'Something went wrong!';

    if(error.status === 500) {
        message = JSON.parse(error.data).message;
    }

    if(error.status === 404) {
        title = 'Not found!';
        message = 'Could not found resource or page!'
    }

    return <PageContent title={title}>
        <p>{message}</p>
    </PageContent>;
}
```