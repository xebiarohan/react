## Tanstack Query II

1. Refetch none in `useMutation` hook
   - When we invalidate the queries, it immediately tries to refetch the data again
   - So if we are on an event and try to delete that event, then it will give 404
   - As we just deleted it and tries to refetch the same because its `queryKey` matches the `queryKey` that we passed in the invalidate queries object
   - So we can do `refetchType` none.
   - It will only refetch when we go to that page or call that endpoint again, not on its own


```
useMutation({
    mutationFn: deleteEvent,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["events"], refetchType: 'none' });
      navigate("/events");
    },
  });
```

2. Modal example

```
export default function Modal({ children, onClose }) {
  const dialog = useRef();

  useEffect(() => {
    const modal = dialog.current;
    modal.showModal();

    return () => {
      modal.close(); 
    };
  }, []);

  return createPortal(
    <dialog className="modal" ref={dialog} onClose={onClose}>
      {children}
    </dialog>,
    document.getElementById('modal')
  );
}


```

3. Optimistic updating
   - When we edit or save something that takes time, but we can update the HMI optimistically like the list of items we are updating
   - We can use `onMutate` property of `useMutation` 
  - `onMutate` get called when we are executing the `mutate` function
  - In the `onMutate` we can call `queryClient.setQueryData()`
  - First we need to cancel all the queries that might be` going to the backend for that `queryKey`
  - Then we can change the cache value using the `setQueryData`
  - `OnMutate` function gets the data that we passes in the `mutate` function


```
  const { mutate } = useMutation({
    mutationFn: updateEvent,
    onMutate: async (data) => {
      const newEvent = data.event;
      await queryClient.cancelQueries({queryKey: ["events", params.id]});
      queryClient.setQueryData(["events", params.id], newEvent);
    }
  });

  function handleSubmit(formData) {
    mutate({id: params.id, event: formData});
    navigate("../");
  }
```

4. In case Mutation Failed ?
   - In last step we see about the optimistic updating
   - But what if the backend update failed
   - So we have to roll back to the previous data
   - For that we have to store the old data in some constant, we can do that using the `queryClient.getQueryData()`
   - In `queryClient.getQueryData()` we can pass the `queryKey`
   - And we have to return that stored data from the `onMutate` function
   - When we have an error while executing the backend query, `onError` gets called
   - `OnError` receives 3 arguments : error, data that we passed and the context.
   - Context contains the returned value of the `onMutate` function
   - We can again call the `query.setQueryData()` to set the previous value
   - To be 100% fail proof we can use `onSettled` that gets called when the query is finished (success or error)
   - In this we can invalidate the queries, so that react will fetch all the data again and gets the latest data.

```
  const { mutate } = useMutation({
    mutationFn: updateEvent,
    onMutate: async (data) => {
      const newEvent = data.event;
      await queryClient.cancelQueries({queryKey: ["events", params.id]});
      const previousData = queryClient.getQueryData(["events", params.id]);
      queryClient.setQueryData(["events", params.id], newEvent);

      return {previousData};
    },
    onError: (error, data, context) => {
      queryClient.setQueryData(["events", params.id], context.previousData);
    },
    onSettled: () => {
      queryClient.invalidateQueries(['events', params.id]);
    }
  });

  function handleSubmit(formData) {
    mutate({id: params.id, event: formData});
    navigate("../");
  }

```

5. Fetching data from query key
   - we can use the `queryKey` data in the query function


```
  const {data, isPending, isError, error} = useQuery({
    queryKey: ['events', {max: 3}],
    queryFn: ({signal, queryKey}) => fetchEvents({signal, ...queryKey[1]}),
    staleTime: 5000,
    gcTime: 100000
  });

```

6. Using the `loader` and `action` with tanstack query
   - we can define the loader and action in the component where we are using the `useQuery` or `useMutation`
   - Loader can help to fetch the data upfront, and before we react the page 
   - that does not mean we have to remove the `useQuery` from the component
   - we will keep it there as it provide other benefits like caching, refetching when we re-trigger the component
   - In the loader we don't have access to the `useQuery` so we can directly use the `queryClient` to fetch the data


```
export function loader({params}) {
  return queryClient.fetchQuery({
    queryKey: ["events", params.id],
    queryFn: ({ signal }) => fetchEvent({ id: params.id, signal }),
  });
}

export async function action({request, params}) {
  const formData = await request.formData();
  const updatedEventData = Object.entries(formData);

  await updateEvent({id: params.id, event: updatedEventData});
  await queryClient.invalidateQueries(['events']);
  return redirect('../');
}

```

7. `useIsFetching`
   - Is used to check if we are fetching some data in application at any place using the React query(`tanstack query`).